{"remainingRequest":"D:\\SOFTWARE\\Programming\\Java\\Projects\\غير منتهية او اختبار\\app\\webui\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\SOFTWARE\\Programming\\Java\\Projects\\غير منتهية او اختبار\\app\\webui\\node_modules\\@nebular\\theme\\components\\popover\\helpers\\adjustment.helper.js","dependencies":[{"path":"D:\\SOFTWARE\\Programming\\Java\\Projects\\غير منتهية او اختبار\\app\\webui\\node_modules\\@nebular\\theme\\components\\popover\\helpers\\adjustment.helper.js","mtime":1519306628000},{"path":"D:\\SOFTWARE\\Programming\\Java\\Projects\\غير منتهية او اختبار\\app\\webui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\SOFTWARE\\Programming\\Java\\Projects\\غير منتهية او اختبار\\app\\webui\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { NbPositioningHelper } from './positioning.helper';\r\nimport { NbPopoverAdjustment, NbPopoverPlacement } from './model';\r\n/**\r\n * Describes the bypass order of the {@link NbPopoverPlacement} in the {@link NbPopoverAdjustment}.\r\n * */\r\nvar NB_ORDERED_PLACEMENTS = (_a = {},\r\n    _a[NbPopoverAdjustment.CLOCKWISE] = [\r\n        NbPopoverPlacement.TOP,\r\n        NbPopoverPlacement.RIGHT,\r\n        NbPopoverPlacement.BOTTOM,\r\n        NbPopoverPlacement.LEFT,\r\n    ],\r\n    _a[NbPopoverAdjustment.COUNTERCLOCKWISE] = [\r\n        NbPopoverPlacement.TOP,\r\n        NbPopoverPlacement.LEFT,\r\n        NbPopoverPlacement.BOTTOM,\r\n        NbPopoverPlacement.RIGHT,\r\n    ],\r\n    _a);\r\nvar NbAdjustmentHelper = /*@__PURE__*/ (function () {\r\n    function NbAdjustmentHelper() {\r\n    }\r\n    /**\r\n     * Calculated {@link NbPopoverPosition} based on placed element, host element,\r\n     * placed element placement and adjustment strategy.\r\n     *\r\n     * @param placed {ClientRect} placed element relatively host.\r\n     * @param host {ClientRect} host element.\r\n     * @param placement {NbPopoverPlacement} placed element placement relatively host.\r\n     * @param adjustment {NbPopoverAdjustment} adjustment strategy.\r\n     *\r\n     * @return {NbPopoverPosition} calculated position.\r\n     * */\r\n    /**\r\n       * Calculated {@link NbPopoverPosition} based on placed element, host element,\r\n       * placed element placement and adjustment strategy.\r\n       *\r\n       * @param placed {ClientRect} placed element relatively host.\r\n       * @param host {ClientRect} host element.\r\n       * @param placement {NbPopoverPlacement} placed element placement relatively host.\r\n       * @param adjustment {NbPopoverAdjustment} adjustment strategy.\r\n       *\r\n       * @return {NbPopoverPosition} calculated position.\r\n       * */\r\n    NbAdjustmentHelper.adjust = /**\r\n       * Calculated {@link NbPopoverPosition} based on placed element, host element,\r\n       * placed element placement and adjustment strategy.\r\n       *\r\n       * @param placed {ClientRect} placed element relatively host.\r\n       * @param host {ClientRect} host element.\r\n       * @param placement {NbPopoverPlacement} placed element placement relatively host.\r\n       * @param adjustment {NbPopoverAdjustment} adjustment strategy.\r\n       *\r\n       * @return {NbPopoverPosition} calculated position.\r\n       * */\r\n        function (placed, host, placement, adjustment) {\r\n            var placements = NB_ORDERED_PLACEMENTS[adjustment].slice();\r\n            var ordered = NbAdjustmentHelper.orderPlacements(placement, placements);\r\n            var possible = ordered.map(function (pl) {\r\n                return ({\r\n                    position: NbPositioningHelper.calcPosition(placed, host, pl),\r\n                    placement: pl,\r\n                });\r\n            });\r\n            return NbAdjustmentHelper.chooseBest(placed, possible);\r\n        };\r\n    /**\r\n     * Searches first adjustment which doesn't go beyond the viewport.\r\n     *\r\n     * @param placed {ClientRect} placed element relatively host.\r\n     * @param possible {NbPopoverPosition[]} possible positions list ordered according to adjustment strategy.\r\n     *\r\n     * @return {NbPopoverPosition} calculated position.\r\n     * */\r\n    /**\r\n       * Searches first adjustment which doesn't go beyond the viewport.\r\n       *\r\n       * @param placed {ClientRect} placed element relatively host.\r\n       * @param possible {NbPopoverPosition[]} possible positions list ordered according to adjustment strategy.\r\n       *\r\n       * @return {NbPopoverPosition} calculated position.\r\n       * */\r\n    NbAdjustmentHelper.chooseBest = /**\r\n       * Searches first adjustment which doesn't go beyond the viewport.\r\n       *\r\n       * @param placed {ClientRect} placed element relatively host.\r\n       * @param possible {NbPopoverPosition[]} possible positions list ordered according to adjustment strategy.\r\n       *\r\n       * @return {NbPopoverPosition} calculated position.\r\n       * */\r\n        function (placed, possible) {\r\n            return possible.find(function (adjust) { return NbAdjustmentHelper.inViewPort(placed, adjust); }) || possible.shift();\r\n        };\r\n    /**\r\n     * Finds out is adjustment doesn't go beyond of the view port.\r\n     *\r\n     * @param placed {ClientRect} placed element relatively host.\r\n     * @param position {NbPopoverPosition} position of the placed element.\r\n     *\r\n     * @return {boolean} true if placed element completely viewport.\r\n     * */\r\n    /**\r\n       * Finds out is adjustment doesn't go beyond of the view port.\r\n       *\r\n       * @param placed {ClientRect} placed element relatively host.\r\n       * @param position {NbPopoverPosition} position of the placed element.\r\n       *\r\n       * @return {boolean} true if placed element completely viewport.\r\n       * */\r\n    NbAdjustmentHelper.inViewPort = /**\r\n       * Finds out is adjustment doesn't go beyond of the view port.\r\n       *\r\n       * @param placed {ClientRect} placed element relatively host.\r\n       * @param position {NbPopoverPosition} position of the placed element.\r\n       *\r\n       * @return {boolean} true if placed element completely viewport.\r\n       * */\r\n        function (placed, position) {\r\n            return position.position.top - window.pageYOffset > 0\r\n                && position.position.left - window.pageXOffset > 0\r\n                && position.position.top + placed.height < window.innerHeight + window.pageYOffset\r\n                && position.position.left + placed.width < window.innerWidth + window.pageXOffset;\r\n        };\r\n    /**\r\n     * Reorder placements list to make placement start point and fit {@link NbPopoverAdjustment}\r\n     *\r\n     * @param placement {NbPopoverPlacement} active placement\r\n     * @param placements {NbPopoverPlacement[]} placements list according to the active adjustment strategy.\r\n     *\r\n     * @return {NbPopoverPlacement[]} correctly ordered placements list.\r\n     *\r\n     * @example order placements for {@link NbPopoverPlacement#RIGHT} and {@link NbPopoverAdjustment#CLOCKWISE}\r\n     * ```\r\n     * const placements = NB_ORDERED_PLACEMENTS[NbPopoverAdjustment.CLOCKWISE];\r\n     * const ordered = orderPlacement(NbPopoverPlacement.RIGHT, placements);\r\n     *\r\n     * expect(ordered).toEqual([\r\n     *  NbPopoverPlacement.RIGHT,\r\n     *  NbPopoverPlacement.BOTTOM,\r\n     *  NbPopoverPlacement.LEFT,\r\n     *  NbPopoverPlacement.TOP,\r\n     * ]);\r\n     * ```\r\n     * */\r\n    /**\r\n       * Reorder placements list to make placement start point and fit {@link NbPopoverAdjustment}\r\n       *\r\n       * @param placement {NbPopoverPlacement} active placement\r\n       * @param placements {NbPopoverPlacement[]} placements list according to the active adjustment strategy.\r\n       *\r\n       * @return {NbPopoverPlacement[]} correctly ordered placements list.\r\n       *\r\n       * @example order placements for {@link NbPopoverPlacement#RIGHT} and {@link NbPopoverAdjustment#CLOCKWISE}\r\n       * ```\r\n       * const placements = NB_ORDERED_PLACEMENTS[NbPopoverAdjustment.CLOCKWISE];\r\n       * const ordered = orderPlacement(NbPopoverPlacement.RIGHT, placements);\r\n       *\r\n       * expect(ordered).toEqual([\r\n       *  NbPopoverPlacement.RIGHT,\r\n       *  NbPopoverPlacement.BOTTOM,\r\n       *  NbPopoverPlacement.LEFT,\r\n       *  NbPopoverPlacement.TOP,\r\n       * ]);\r\n       * ```\r\n       * */\r\n    NbAdjustmentHelper.orderPlacements = /**\r\n       * Reorder placements list to make placement start point and fit {@link NbPopoverAdjustment}\r\n       *\r\n       * @param placement {NbPopoverPlacement} active placement\r\n       * @param placements {NbPopoverPlacement[]} placements list according to the active adjustment strategy.\r\n       *\r\n       * @return {NbPopoverPlacement[]} correctly ordered placements list.\r\n       *\r\n       * @example order placements for {@link NbPopoverPlacement#RIGHT} and {@link NbPopoverAdjustment#CLOCKWISE}\r\n       * ```\r\n       * const placements = NB_ORDERED_PLACEMENTS[NbPopoverAdjustment.CLOCKWISE];\r\n       * const ordered = orderPlacement(NbPopoverPlacement.RIGHT, placements);\r\n       *\r\n       * expect(ordered).toEqual([\r\n       *  NbPopoverPlacement.RIGHT,\r\n       *  NbPopoverPlacement.BOTTOM,\r\n       *  NbPopoverPlacement.LEFT,\r\n       *  NbPopoverPlacement.TOP,\r\n       * ]);\r\n       * ```\r\n       * */\r\n        function (placement, placements) {\r\n            var index = placements.indexOf(placement);\r\n            var start = placements.splice(index, placements.length);\r\n            return start.concat.apply(start, placements);\r\n        };\r\n    return NbAdjustmentHelper;\r\n}());\r\nexport { NbAdjustmentHelper };\r\nvar _a;\r\n//# sourceMappingURL=adjustment.helper.js.map \r\n",null]}