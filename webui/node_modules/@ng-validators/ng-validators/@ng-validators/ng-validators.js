import { Directive, Input, NgModule, forwardRef } from '@angular/core';
import { AbstractControl, NG_VALIDATORS, Validators } from '@angular/forms';

const BASE64_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => Base64Validator),
    multi: true
};
class Base64Validator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return base64(c);
    }
}
Base64Validator.decorators = [
    { type: Directive, args: [{
                selector: '[base64][formControlName],[base64][formControl],[base64][ngModel]',
                providers: [BASE64_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
Base64Validator.ctorParameters = () => [];

/**
 * @param {?} obj
 * @return {?}
 */
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
/**
 * @param {?} obj
 * @return {?}
 */
function isDate(obj) {
    return !/Invalid|NaN/.test(new Date(obj).toString());
}

const base64 = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    return /^(?:[A-Z0-9+\/]{4})*(?:[A-Z0-9+\/]{2}==|[A-Z0-9+\/]{3}=|[A-Z0-9+\/]{4})$/i.test(v) ? null : { 'base64': true };
};

const CREDIT_CARD_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => CreditCardValidator),
    multi: true
};
class CreditCardValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return creditCard(c);
    }
}
CreditCardValidator.decorators = [
    { type: Directive, args: [{
                selector: '[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]',
                providers: [CREDIT_CARD_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
CreditCardValidator.ctorParameters = () => [];

const creditCard = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    let /** @type {?} */ sanitized = v.replace(/[^0-9]+/g, '');
    // problem with chrome
    // tslint:disable-next-line:max-line-length
    if (!(/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/.test(sanitized))) {
        return { creditCard: true };
    }
    let /** @type {?} */ sum = 0;
    let /** @type {?} */ digit;
    let /** @type {?} */ tmpNum;
    let /** @type {?} */ shouldDouble;
    for (let /** @type {?} */ i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, (i + 1));
        tmpNum = parseInt(digit, 10);
        if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
                sum += ((tmpNum % 10) + 1);
            }
            else {
                sum += tmpNum;
            }
        }
        else {
            sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
    }
    if (Boolean((sum % 10) === 0 ? sanitized : false)) {
        return null;
    }
    return { creditCard: true };
};

const DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => DateValidator),
    multi: true
};
class DateValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return date(c);
    }
}
DateValidator.decorators = [
    { type: Directive, args: [{
                selector: '[date][formControlName],[date][formControl],[date][ngModel]',
                providers: [DATE_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
DateValidator.ctorParameters = () => [];

const date = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    return isDate(v) ? null : { date: true };
};

const DATE_ISO_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => DateISOValidator),
    multi: true
};
class DateISOValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return dateISO(c);
    }
}
DateISOValidator.decorators = [
    { type: Directive, args: [{
                selector: '[dateISO][formControlName],[dateISO][formControl],[dateISO][ngModel]',
                providers: [DATE_ISO_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
DateISOValidator.ctorParameters = () => [];

const dateISO = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    return /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(v) ? null : { dateISO: true };
};

const DIGITS_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => DigitsValidator),
    multi: true
};
class DigitsValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return digits(c);
    }
}
DigitsValidator.decorators = [
    { type: Directive, args: [{
                selector: '[digits][formControlName],[digits][formControl],[digits][ngModel]',
                providers: [DIGITS_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
DigitsValidator.ctorParameters = () => [];

const digits = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    return /^\d+$/.test(v) ? null : { digits: true };
};

const EMAIL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => EmailValidator),
    multi: true
};
class EmailValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return email(c);
    }
}
EmailValidator.decorators = [
    { type: Directive, args: [{
                selector: '[email][formControlName],[email][formControl],[email][ngModel]',
                providers: [EMAIL_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
EmailValidator.ctorParameters = () => [];

const email = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    // tslint:disable-next-line:max-line-length
    return /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v) ? null : { 'email': true };
};

const EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => EqualValidator),
    multi: true
};
class EqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = equal(this.equal);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'equal') {
                this.validator = equal(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
EqualValidator.decorators = [
    { type: Directive, args: [{
                selector: '[equal][formControlName],[equal][formControl],[equal][ngModel]',
                providers: [EQUAL_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
EqualValidator.ctorParameters = () => [];
EqualValidator.propDecorators = {
    'equal': [{ type: Input },],
};

const equal = (val) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = control.value;
        return val === v ? null : { equal: true };
    };
};

const EQUAL_TO_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => EqualToValidator),
    multi: true
};
class EqualToValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = equalTo(this.equalTo);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
EqualToValidator.decorators = [
    { type: Directive, args: [{
                selector: '[equalTo][formControlName],[equalTo][formControl],[equalTo][ngModel]',
                providers: [EQUAL_TO_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
EqualToValidator.ctorParameters = () => [];
EqualToValidator.propDecorators = {
    'equalTo': [{ type: Input },],
};

const equalTo = (equalControl) => {
    let /** @type {?} */ subscribe = false;
    return (control) => {
        if (!subscribe) {
            subscribe = true;
            equalControl.valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        let /** @type {?} */ v = control.value;
        return equalControl.value === v ? null : { equalTo: true };
    };
};

const GREATER_THAN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => GreaterThanValidator),
    multi: true
};
class GreaterThanValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = gt(this.gt);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'gt') {
                this.validator = gt(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
GreaterThanValidator.decorators = [
    { type: Directive, args: [{
                selector: '[gt][formControlName],[gt][formControl],[gt][ngModel]',
                providers: [GREATER_THAN_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
GreaterThanValidator.ctorParameters = () => [];
GreaterThanValidator.propDecorators = {
    'gt': [{ type: Input },],
};

const gt = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = +control.value;
        return v > +val ? null : { gt: true };
    };
};

const GREATER_THAN_EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => GreaterThanEqualValidator),
    multi: true
};
class GreaterThanEqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = gte(this.gte);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'gte') {
                this.validator = gte(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
GreaterThanEqualValidator.decorators = [
    { type: Directive, args: [{
                selector: '[gte][formControlName],[gte][formControl],[gte][ngModel]',
                providers: [GREATER_THAN_EQUAL_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
GreaterThanEqualValidator.ctorParameters = () => [];
GreaterThanEqualValidator.propDecorators = {
    'gte': [{ type: Input },],
};

const gte = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = +control.value;
        return v >= +val ? null : { gte: true };
    };
};

const JSON_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => JSONValidator),
    multi: true
};
class JSONValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return json(c);
    }
}
JSONValidator.decorators = [
    { type: Directive, args: [{
                selector: '[json][formControlName],[json][formControl],[json][ngModel]',
                providers: [JSON_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
JSONValidator.ctorParameters = () => [];

const json = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    try {
        let /** @type {?} */ obj = JSON.parse(v);
        if (Boolean(obj) && typeof obj === 'object') {
            return null;
        }
    }
    catch (e) {
    }
    return { json: true };
};

const LESS_THAN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => LessThanValidator),
    multi: true
};
class LessThanValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = lt(this.lt);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'lt') {
                this.validator = lt(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
LessThanValidator.decorators = [
    { type: Directive, args: [{
                selector: '[lt][formControlName],[lt][formControl],[lt][ngModel]',
                providers: [LESS_THAN_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
LessThanValidator.ctorParameters = () => [];
LessThanValidator.propDecorators = {
    'lt': [{ type: Input },],
};

const lt = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = +control.value;
        return v < +val ? null : { lt: true };
    };
};

const LESS_THAN_EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => LessThanEqualValidator),
    multi: true
};
class LessThanEqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = lte(this.lte);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'lte') {
                this.validator = lte(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
LessThanEqualValidator.decorators = [
    { type: Directive, args: [{
                selector: '[lte][formControlName],[lte][formControl],[lte][ngModel]',
                providers: [LESS_THAN_EQUAL_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
LessThanEqualValidator.ctorParameters = () => [];
LessThanEqualValidator.propDecorators = {
    'lte': [{ type: Input },],
};

const lte = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = +control.value;
        return v <= +val ? null : { lte: true };
    };
};

const MAX_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MaxValidator),
    multi: true
};
class MaxValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = max(this.max);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'max') {
                this.validator = max(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MaxValidator.decorators = [
    { type: Directive, args: [{
                selector: '[max][formControlName],[max][formControl],[max][ngModel]',
                providers: [MAX_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
MaxValidator.ctorParameters = () => [];
MaxValidator.propDecorators = {
    'max': [{ type: Input },],
};

const max = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = +control.value;
        return v <= +val ? null : { actualValue: v, requiredValue: +val, max: true };
    };
};

const MAX_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MaxDateValidator),
    multi: true
};
class MaxDateValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = maxDate(this.maxDate);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'maxDate') {
                this.validator = maxDate(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MaxDateValidator.decorators = [
    { type: Directive, args: [{
                selector: '[maxDate][formControlName],[maxDate][formControl],[maxDate][ngModel]',
                providers: [MAX_DATE_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
MaxDateValidator.ctorParameters = () => [];
MaxDateValidator.propDecorators = {
    'maxDate': [{ type: Input },],
};

const maxDate = (val) => {
    let /** @type {?} */ subscribe = false;
    let /** @type {?} */ otherValue = val;
    const /** @type {?} */ subscribable = val instanceof AbstractControl;
    if (!subscribable && !isDate(val) && !(val instanceof Function)) {
        throw Error('maxDate value must be or return a formatted date');
    }
    return (control) => {
        if (subscribable && !subscribe) {
            subscribe = true;
            ((val)).valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ d = new Date(control.value);
        if (!isDate(d)) {
            return {
                minDate: true
            };
        }
        if (val instanceof Function) {
            otherValue = val();
        }
        if (subscribable) {
            otherValue = val.value;
        }
        return d <= new Date(otherValue) ? null : { maxDate: true };
    };
};

const MIN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MinValidator),
    multi: true
};
class MinValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = min(this.min);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'min') {
                this.validator = min(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MinValidator.decorators = [
    { type: Directive, args: [{
                selector: '[min][formControlName],[min][formControl],[min][ngModel]',
                providers: [MIN_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
MinValidator.ctorParameters = () => [];
MinValidator.propDecorators = {
    'min': [{ type: Input },],
};

const min = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = +control.value;
        return v >= +val ? null : { actualValue: v, requiredValue: +val, min: true };
    };
};

const MIN_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MinDateValidator),
    multi: true
};
class MinDateValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = minDate(this.minDate);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'minDate') {
                this.validator = minDate(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MinDateValidator.decorators = [
    { type: Directive, args: [{
                selector: '[minDate][formControlName],[minDate][formControl],[minDate][ngModel]',
                providers: [MIN_DATE_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
MinDateValidator.ctorParameters = () => [];
MinDateValidator.propDecorators = {
    'minDate': [{ type: Input },],
};

const minDate = (val) => {
    let /** @type {?} */ subscribe = false;
    let /** @type {?} */ otherValue = val;
    const /** @type {?} */ subscribable = val instanceof AbstractControl;
    if (!subscribable && !isDate(val) && !(val instanceof Function)) {
        throw Error('minDate value must be or return a formatted date');
    }
    return (control) => {
        if (subscribable && !subscribe) {
            subscribe = true;
            ((val)).valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ d = new Date(control.value);
        if (!isDate(d)) {
            return { minDate: true };
        }
        if (val instanceof Function) {
            otherValue = val();
        }
        if (subscribable) {
            otherValue = val.value;
        }
        return d >= new Date(otherValue) ? null : { minDate: true };
    };
};

const NOT_EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NotEqualValidator),
    multi: true
};
class NotEqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = notEqual(this.notEqual);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'notEqual') {
                this.validator = notEqual(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
NotEqualValidator.decorators = [
    { type: Directive, args: [{
                selector: '[notEqual][formControlName],[notEqual][formControl],[notEqual][ngModel]',
                providers: [NOT_EQUAL_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
NotEqualValidator.ctorParameters = () => [];
NotEqualValidator.propDecorators = {
    'notEqual': [{ type: Input },],
};

const notEqual = (val) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = control.value;
        return val !== v ? null : { notEqual: true };
    };
};

const NOT_EQUAL_TO_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NotEqualToValidator),
    multi: true
};
class NotEqualToValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = notEqualTo(this.notEqualTo);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
NotEqualToValidator.decorators = [
    { type: Directive, args: [{
                selector: '[notEqualTo][formControlName],[notEqualTo][formControl],[notEqualTo][ngModel]',
                providers: [NOT_EQUAL_TO_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
NotEqualToValidator.ctorParameters = () => [];
NotEqualToValidator.propDecorators = {
    'notEqualTo': [{ type: Input },],
};

const notEqualTo = (notEqualControl) => {
    let /** @type {?} */ subscribe = false;
    return (control) => {
        if (!subscribe) {
            subscribe = true;
            notEqualControl.valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        let /** @type {?} */ v = control.value;
        return notEqualControl.value !== v ? null : { notEqualTo: true };
    };
};

const NUMBER_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NumberValidator),
    multi: true
};
class NumberValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return number(c);
    }
}
NumberValidator.decorators = [
    { type: Directive, args: [{
                selector: '[number][formControlName],[number][formControl],[number][ngModel]',
                providers: [NUMBER_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
NumberValidator.ctorParameters = () => [];

const number = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    return /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(v) ? null : { 'number': true };
};

const RANGE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => RangeValidator),
    multi: true
};
class RangeValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = range(this.range);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'range') {
                this.validator = range(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
RangeValidator.decorators = [
    { type: Directive, args: [{
                selector: '[range][formControlName],[range][formControl],[range][ngModel]',
                providers: [RANGE_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
RangeValidator.ctorParameters = () => [];
RangeValidator.propDecorators = {
    'range': [{ type: Input },],
};

const range = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = +control.value;
        return v >= val[0] && v <= val[1] ? null : { actualValue: v, requiredValue: val, range: true };
    };
};

const RANGE_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => RangeLengthValidator),
    multi: true
};
class RangeLengthValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = rangeLength(this.rangeLength);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'rangeLength') {
                this.validator = rangeLength(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
RangeLengthValidator.decorators = [
    { type: Directive, args: [{
                selector: '[rangeLength][formControlName],[rangeLength][formControl],[rangeLength][ngModel]',
                providers: [RANGE_LENGTH_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
RangeLengthValidator.ctorParameters = () => [];
RangeLengthValidator.propDecorators = {
    'rangeLength': [{ type: Input },],
};

const rangeLength = (val) => {
    return (control) => {
        if (!isPresent(val)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = control.value;
        return v.length >= val[0] && v.length <= val[1] ? null : { rangeLength: true };
    };
};

const URL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => UrlValidator),
    multi: true
};
class UrlValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return url(c);
    }
}
UrlValidator.decorators = [
    { type: Directive, args: [{
                selector: '[url][formControlName],[url][formControl],[url][ngModel]',
                providers: [URL_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
UrlValidator.ctorParameters = () => [];

const url = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    let /** @type {?} */ v = control.value;
    // tslint:disable-next-line:max-line-length
    return /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(v) ? null : { 'url': true };
};

const UUID_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => UUIDValidator),
    multi: true
};
class UUIDValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = uuid(this.uuid);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ key in changes) {
            if (key === 'uuid') {
                this.validator = uuid(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
UUIDValidator.decorators = [
    { type: Directive, args: [{
                selector: '[uuid][formControlName],[uuid][formControl],[uuid][ngModel]',
                providers: [UUID_VALIDATOR]
            },] },
];
/**
 * @nocollapse
 */
UUIDValidator.ctorParameters = () => [];
UUIDValidator.propDecorators = {
    'uuid': [{ type: Input },],
};

const uuids = {
    '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    'all': /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
};
const uuid = (version) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        let /** @type {?} */ v = control.value;
        let /** @type {?} */ pattern = uuids[version] || uuids.all;
        return (new RegExp(pattern)).test(v) ? null : { uuid: true };
    };
};

const CustomValidators = {
    base64,
    creditCard,
    date,
    dateISO,
    digits,
    email,
    equal,
    equalTo,
    gt,
    gte,
    json,
    lt,
    lte,
    max,
    maxDate,
    min,
    minDate,
    notEqual,
    notEqualTo,
    number,
    range,
    rangeLength,
    url,
    uuid
};
const CUSTOM_FORM_DIRECTIVES = [
    Base64Validator,
    CreditCardValidator,
    DateValidator,
    DateISOValidator,
    DigitsValidator,
    EmailValidator,
    EqualValidator,
    EqualToValidator,
    GreaterThanValidator,
    GreaterThanEqualValidator,
    JSONValidator,
    LessThanValidator,
    LessThanEqualValidator,
    MaxValidator,
    MaxDateValidator,
    MinValidator,
    MinDateValidator,
    NotEqualValidator,
    NotEqualToValidator,
    NumberValidator,
    RangeValidator,
    RangeLengthValidator,
    UrlValidator,
    UUIDValidator
];
class CustomFormsModule {
}
CustomFormsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CUSTOM_FORM_DIRECTIVES],
                exports: [CUSTOM_FORM_DIRECTIVES]
            },] },
];
/**
 * @nocollapse
 */
CustomFormsModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { CustomValidators, CustomFormsModule, Base64Validator as ɵy, base64 as ɵa, CreditCardValidator as ɵz, creditCard as ɵb, DateValidator as ɵba, date as ɵc, DateISOValidator as ɵbb, dateISO as ɵd, DigitsValidator as ɵbc, digits as ɵe, EmailValidator as ɵbd, email as ɵf, EqualValidator as ɵbe, equal as ɵg, EqualToValidator as ɵbf, equalTo as ɵh, GreaterThanValidator as ɵbg, gt as ɵi, GreaterThanEqualValidator as ɵbh, gte as ɵj, JSONValidator as ɵbi, json as ɵk, LessThanValidator as ɵbj, lt as ɵl, LessThanEqualValidator as ɵbk, lte as ɵm, MaxValidator as ɵbl, max as ɵn, MaxDateValidator as ɵbm, maxDate as ɵo, MinValidator as ɵbn, min as ɵp, MinDateValidator as ɵbo, minDate as ɵq, NotEqualValidator as ɵbp, notEqual as ɵr, NotEqualToValidator as ɵbq, notEqualTo as ɵs, NumberValidator as ɵbr, number as ɵt, RangeValidator as ɵbs, range as ɵu, RangeLengthValidator as ɵbt, rangeLength as ɵv, UrlValidator as ɵbu, url as ɵw, UUIDValidator as ɵbv, uuid as ɵx };
//# sourceMappingURL=ng-validators.js.map
